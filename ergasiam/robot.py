# robot_mid.py
from collections import deque
import sys # Θα χρειαστεί για την ανάγνωση παραμέτρων

ROWS, COLS = 10, 10 #αναγράφουμε ότι μέσα στο αρχείο txt υπάρχουν 10 γραμμές και 10 στήλες
EMPTY, OBST, ITEM = ".", "#", "*"

def load_world(path: str) -> list[list[str]]: #Η συνάρτηση δέχεται ως όρισμα μια συμνβολοσειρά που είναι το όνομα του αρχείου και επιστρέφει μια δι-διάστατη λίστα/
    """
    Φορτώνει τον κείμενο από το αρχείο.
    Ελέγχει τις διαστάσεις και τα σύμβολα.
    """
    world = [] 
    
    try:
        with open(path, "r", encoding="utf-8") as f: #Το αρχείο ανοίγει σε λειτουργία ανάγνωσης
            for line in f:
                row = line.strip().split() # Διαβάζει τη γραμμή, αφαιρεί περιττά κενά και χωρίζει τα σύμβολα
                if row:
                    world.append(row) #Αν η γραμμή δεν είναι κενή, προσθέτει τη λίστα στη  λίστα world
    except FileNotFoundError: # Η περίπτωση που δεν βρεθεί το αρχείο.
        print(f"Σφάλμα: Δεν βρέθηκε το αρχείο {path}")
        sys.exit(1)

    assert len(world) == ROWS and all(len(r) == COLS for r in world), "Λάθος διαστάσεις world.txt (Πρέπει να είναι 10x10)."  # Η εντολή assert χρησιμοποιείται για τον εντοπισμό των λαθών. Στην συγκεκριμένη περ'ιπτωση ελέγχει αν οι διαστάσεις είναι σωστές.

   
    valid = {EMPTY, OBST, ITEM} #Ελέγχει αν το σύβολο που διαβάζει υπάρχει στα έγκυρα 
    for r in world:
        for s in r:
            assert s in valid, f"Άκυρο σύμβολο βρέθηκε: {s}. Έγκυρα: {valid}"
    
    return world

def print_world(world: list[list[str]], r: int, c: int) -> None: #  Τυπώνει τον κόσμο με το ρομπότ στη θέση (r, c)
    for i in range(ROWS):
        line = []
        for j in range(COLS):
            line.append("R" if (i, j) == (r, c) else world[i][j])# Αν η θέση (i, j) είναι η θέση του ρομπότ (r, c), τυπώνουμε 'R', αλλιώς το περιεχόμενο του κελιού
        print(" ".join(line)) #Εδώ ενώνουμε τα στοιχεία σε μια συμβολοσειρά η οποία έχει κενό διάστημα ανάμεσα στα στοιχεία και την τυπώνουμε
    print()
def in_bounds(r: int, c: int) -> bool: #Τονίζουμε ότι θέλει να μας επιστρέψει μια boolean τιμή. Αυτή την συνάρτηση την χρησιμοποιήσαμε για να ελέγξομε τα όρια του πίνακα.
    return 0 <= r < ROWS and 0 <= c < COLS # Ελέγχει αν ο δείκτης r είναι έγκυρος για τις γραμμές και αν ο δείκτης c είναι έγκυρος για τις στήλες.
def neighbors(world, r: int, c: int): # Παράγει τις έγκυρες γειτονικές θέσεις από τη θέση (r, c)
   
    
    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:# Όλες οι πιθανές κινήσεις: Πάνω, Κάτω, Αριστερά, Δεξιά [cite: 139]
        nr, nc = r + dr, c + dc # Υπολογίζουμε τις νέες συντεταγμένες
        if in_bounds(nr, nc) and world[nr][nc] != OBST:  # Ελέγχουμε αν είναι εντός ορίων ΚΑΙ δεν είναι εμπόδιο 
            yield nr, nc # με το yield επιστρέφουμε πολλαπλές τιμές, μία για κάθε φορά που καλείται η συνάρτηση
# robot_mid.py (Συνέχεια)

def next_step_sweep(world, r: int, c: int, direction: int): #Υπολογίζει το επόμενο βήμα για τηξν στρατιγική Sweep
    #Κίνηση προς τα δεξιά και άφιξη στο δεξί άκρο
    if direction == 1 and c == COLS - 1:
        # Αν φτάσει στο δεξί άκρο (στήλη 9):
        # Κατεβαίνει μία γραμμή (r+1)
        # Αλλάζει κατεύθυνση σε ΑΡΙΣΤΕΡΑ (-1)
        # Προσοχή: Ελέγχουμε αν r+1 είναι εντός ορίων, αλλιώς μένει στην ίδια γραμμή
        nr = r + 1 if r + 1 < ROWS else r
        nc = COLS-1 # παραμένει στην τελευταία στήλη προς το παρόν, θα κινηθεί μετά
        new_direction = -1
        return (nr, nc, new_direction)
    
    #Κίνηση προς τα αριστερά και άφιξη στο αριστερό άκρο
    if direction == -1 and c == 0:
        # Αν φτάσει στο αριστερό άκρο (στήλη 0):
        # Κατεβαίνει μία γραμμή (r+1)
        # Αλλάζει κατεύθυνση σε ΔΕΞΙΑ (+1)
        nr = r + 1 if r + 1 < ROWS else r
        nc = 0 # παραμένει στην πρώτη στήλη προς το παρόν
        new_direction = 1
        return (nr, nc, new_direction)
    
    #Απλή κίνηση δεξιά ή αριστερά
    #Συνεχίζει στην ίδια γραμμή, αυξάνοντας/μειώνοντας τη στήλη ανάλογα με το direction
    nr = r
    nc = c + direction
    
    #Χειρισμός εμποδίων στη στρατηγική Sweep:
    #Εάν η επόμενη θέση είναι εμπόδιο, το ρομπότ μένει στην τρέχουσα θέση
    if world[nr][nc] == OBST:
        return (r, c, direction)
    return (nr, nc, direction)
        
          


def bfs_path_to_nearest_item(world, start: tuple[int, int]) -> list[tuple[int, int]]: # Επιστρέφει τη συντομότερη διαδρομή προς το πλησιέστερο αντικείμενο
    
    start_r, start_c = start
    queue = deque([(start, [])])# Χρησιμοποιούμε μια ουρά (deque) για να αποθηκεύσουμε τους κόμβους που πρέπει να επισκεφθούμε.
    visited = {start} # Είναι ένα σύνολο που καταγράφει όλες τις θέσεις που έχουν ήδη εξέταστει
    while queue: # Όσο η ουρά δεν είναι άδεια , ο βρόχος συνεχίζει.
        (r, c), path = queue.popleft() # Παίρνουμε τον πρώτο κόμβο και τη διαδρομή μέχρι αυτόν
        if world[r][c] == ITEM:  # Ελέγχουμε αν το τρέχον κελί περιέχει αντικείμενο.
            if (r, c) != start: # Βρέθηκε αντικείμενο σε μη αρχική θέση
                return path      # Επιστρέφουμε τη διαδρομή (η οποία δεν περιλαμβάνει το start)
        for nr, nc in neighbors(world, r, c):  # Η συνάρτηση neighbors μας δίνει μόνο τα έγκυρα γειτονικά κελιά
            new_pos = (nr, nc)
            
            if new_pos not in visited: # Για κάθε γείτονα (nr, nc) που δεν έχει επισκεφθεί ακόμα
                new_path = path + [new_pos] # Δημιουργούμε τη νέα διαδρομή προσθέτοντας τον νέο γείτονα στην παλιά διαδρομή.
                visited.add(new_pos) # Η νέα θέση προστίθεται στο σύνολο visited
                queue.append((new_pos, new_path)) # Μπαίνει στο τέλος της ουράς για μελλοντική εξέταση
    return [] # Δεν βρέθηκαν αντικείμενα



def next_step_bfs(world, pos: tuple[int, int]) -> tuple[int, int]: # Υπολογίζει το επόμενο βήμα για τη στρατηγική BFS
    path = bfs_path_to_nearest_item(world, pos)  # Βρίσκει τη συντομότερη διαδρομή (λίστα θέσεων)
    if path: # Αν βρεθεί διαδρομή, επιστρέφει το πρώτο στοιχείο της διαδρομής.
        return path[0] # Αν δεν υπάρχει διαδρομή ,το ρομπότ μένει στην τρέχουσα θέση 
    return pos  


def run(strategy: str, world_path: str):#Κύρια συνάρτηση προσομοίωσης η οποία περιλαμβάνει τον έλεγχο τερματισμού και την τελική έξοδο.
    
    world = load_world(world_path) # Φόρτωση κόσμου από αρχείο
    if not isinstance(world, list) or not all(isinstance(row, list) for row in world):
        print("FATAL ERROR: 'world' is not a list of lists after load_world.")
        sys.exit(1)
    initial_world = [row[:] for row in world] # Δημιουργεί αντίγραφο του αρχικού κόσμου.
    r, c = 0, 0 # Το ρομπότ ξεκινά στη θέση (0,0)
    direction = 1 # Χρησιμοποιείται μόνο για τη Sweep. Ξεκινά δεξιά.
    score, steps = 0, 0
    # Εμφάνιση αρχικών δεδομένων 
    print(f"==================================================")
    print(f"Στρατηγική: {strategy.upper()}")
    print(f"Αρχικός Κόσμος:")
    print_world(initial_world, r, c) # Εμφανίζουμε τον initial_world χωρίς το ρομπότ 
    print(f"==================================================")
    # Κύριος βρόχος προσομοίωσης
    while steps < 80: 
        
        # Υπολογισμός επόμενης θέσης πριν την κίνηση
        prev_r, prev_c = r, c
        nr, nc = r, c # Προσωρινή αρχικοποίηση

        if strategy.upper() == "BFS": # Καλεί την κατάλληλη συνάρτηση για κάθε στρατηγική.
            nr, nc = next_step_bfs(world, (r, c)) 
        elif strategy.upper() == "SWEEP":
            nr, nc, direction = next_step_sweep(world, r, c, direction)       
        # Αν η στρατηγική είναι άκυρη, πρέπει να τερματίσει.
        else:
            print("Σφάλμα: Άγνωστη στρατηγική.")
            break 
        
        
        
            
        # Κίνηση (μόνο αν άλλαξε η θέση, αλλιώς μέτρημα βήματος)
        if (nr, nc) != (r, c): # Ελέγχει αν η νέα θέση είναι διαφορετική από την τρέχουσα
             r, c = nr, nc # Ενημερώνει τη θέση του ρομπότ και πραγματοποιεί την κίνηση.
             steps += 1  # Μετράμε βήμα αν έγινε η κίνηση
        elif (nr, nc) == (r, c) :
            steps += 1 
             # Αν το BFS δεν βρήκε διαδρομή, μένει στη θέση του και δεν μετράει βήμα ή μετράει βήμα αν έγινε κίνηση ή αν το ρομπότ προσπάθησε να κινηθεί  
              # Μετράμε βήμα αν και δεν κινήθηκε (προσπάθεια κίνησης)

        # Συλλογή αντικειμένου αν υπάρχει στη νέα θέση
        if world[r][c] == ITEM: # Ελέγχει αν υπάρχει αντικείμενο στην τρέχουσα θέση
            if steps==23:
                print(f"DEBUG STEP 23: Pos=({r},{c}), World content: {world[r][c]}, Score: {score}")
            if steps == 23:
                print(f"DEBUG STEP 23 (Check): Pos=({r},{c}), Content={world[r][c]}")
            print(f"[Step {steps}] Συλλέχθηκε αντικείμενο στη θέση: ({r}, {c})") #Τυπώνει την θέση του αντικειμένου και το βήμα συλλογής.
            world[r][c] = EMPTY  #Συλλέγεται το αντικείμενο και το κελί γίνεται κενό
            score += 1 
        # Έλεγχος τερματισμού (λόγω έλλειψης αντικειμένων)
        if not any(ITEM in row for row in world): 
            break
        
        # Εμφάνιση κατάστασης ανά 10 βήματα 
        if steps > 0 and steps % 10 == 0: #Ελέγχει αν είναι πολλαπλάσιο του 10 σε αυτό το βήμα.
            print(f"--- Βήμα {steps} | Θέση=({r},{c}) | Συλλογή={score} ---") # Εμφανίζει την τρέχουσα κατάσταση , το σκορ και το πλέγμα.
            print_world(world, r, c) 

    #  Τελική Έξοδος και Αποτελέσματα 
    reason = "Τέλος αντικειμένων" if not any(ITEM in row for row in world) else "Ολοκλήρωση 80 βημάτων" #Καθορίζει τον λόγο τερματισμού
    
    print(f"==================================================")
    print(f"Ολοκλήρωση: {reason}") # Εκτυπώνει τον λόγο του τερματικού
    print(f"Συνολικό σκορ (Αντικείμενα): {score}") # Εκτυπώνει πόσα αντικείμενα συλλέχθηκαν
    print(f"Συνολικός αριθμός βημάτων: {steps}") #Εκτυπώνει τον συνολικό αριθμό βημάτων.
    print(f"Τελική μορφή Κόσμου:")
    print_world(world, r, c) # Εκτυπώνει τον τελικό κόσμο με τη θέση του ρομπότ
    print(f"==================================================")

# Κεντρικό block εκτέλεσης
if __name__ == "__main__":
    if len(sys.argv) == 3: # Έλεγχος αν στο πρόγραμμα εκτελέστηκαν 3 ορίσματα.
        world_file = sys.argv[1] # Το πρώτο όρισμα είναι το όνομα του αρχείου κόσμου
        strategy_input = sys.argv[2].upper() # Το δεύτερο όρισμα είναι η στρατηγική (μετατρέπεται σε κεφαλαία)
    
    # Εναλλακτική: Διάβασμα από input (όπως ζητήθηκε προηγουμένως)
    else:
        print("Παρακαλώ εισάγετε τις παραμέτρους χειροκίνητα.")
        world_file = input("Δώσε όνομα αρχείου Κόσμου (π.χ. world.txt): ")
        strategy_input = input("Δώσε στρατηγική (BFS ή Sweep): ").upper()
        
    if strategy_input not in ["BFS", "SWEEP"]: # Έλεγχος εγκυρότητας στρατηγικής
        print("Μη έγκυρη στρατηγική. Χρησιμοποιείται η BFS ως προεπιλογή.")
        strategy_input = "BFS"
        
    run(strategy_input, world_file)